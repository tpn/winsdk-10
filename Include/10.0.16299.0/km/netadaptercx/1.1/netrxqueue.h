/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    NetRxQueue.h

Abstract:

    This is the interfaces for the NetRxQueue

Environment:

    kernel mode only

Revision History:

--*/

//
// NOTE: This header is generated by stubwork.  Please make any 
//       modifications to the corresponding template files 
//       (.x or .y) and use stubwork to regenerate the header
//

#ifndef _NETRXQUEUE_H_
#define _NETRXQUEUE_H_

#ifndef WDF_EXTERN_C
  #ifdef __cplusplus
    #define WDF_EXTERN_C       extern "C"
    #define WDF_EXTERN_C_START extern "C" {
    #define WDF_EXTERN_C_END   }
  #else
    #define WDF_EXTERN_C
    #define WDF_EXTERN_C_START
    #define WDF_EXTERN_C_END
  #endif
#endif

WDF_EXTERN_C_START




#define NET_RX_QUEUE_DEFAULT_ALIGNMENT ((ULONG)(-1))

typedef struct NETRXQUEUE_INIT *PNETRXQUEUE_INIT;

typedef
_Function_class_(EVT_RXQUEUE_CANCEL)
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
EVT_RXQUEUE_CANCEL(
    _In_
    NETRXQUEUE RxQueue
    );

typedef EVT_RXQUEUE_CANCEL *PFN_RXQUEUE_CANCEL;

typedef
_Function_class_(EVT_RXQUEUE_SET_NOTIFICATION_ENABLED)
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
EVT_RXQUEUE_SET_NOTIFICATION_ENABLED(
    _In_
    NETRXQUEUE RxQueue,
    _In_
    BOOLEAN NotificationEnabled
    );

typedef EVT_RXQUEUE_SET_NOTIFICATION_ENABLED *PFN_RXQUEUE_SET_NOTIFICATION_ENABLED;

typedef
_Function_class_(EVT_RXQUEUE_ADVANCE)
_IRQL_requires_same_
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
EVT_RXQUEUE_ADVANCE(
    _In_ 
    NETRXQUEUE RxQueue
    );

typedef EVT_RXQUEUE_ADVANCE *PFN_RXQUEUE_ADVANCE;

typedef struct _NET_RXQUEUE_BUFFER_LAYOUT_HINT
{
    //
    // Minimum space that should be unused in
    // the start of the first fragment
    //
    ULONG MinimumBackfillSize;

    //
    // Ideal alignment for the start of the L3
    // header. The value is in the form N-1,
    // where N is the alignment.
    //
    ULONG L3HeaderAlignment;

} NET_RXQUEUE_BUFFER_LAYOUT_HINT, *PNET_RXQUEUE_BUFFER_LAYOUT_HINT;

typedef struct _NET_RXQUEUE_CONFIG
{
    //
    // Size of structure. 
    //
    ULONG Size;

    PFN_RXQUEUE_CANCEL EvtRxQueueCancel;

    PFN_RXQUEUE_SET_NOTIFICATION_ENABLED EvtRxQueueSetNotificationEnabled;

    PFN_RXQUEUE_ADVANCE EvtRxQueueAdvance;

    ULONG AllocationSize;
    ULONG AlignmentRequirement;

    ULONG RingBufferNumberOfElementsHint;

} NET_RXQUEUE_CONFIG, *PNET_RXQUEUE_CONFIG;

VOID
FORCEINLINE
NET_RXQUEUE_CONFIG_INIT(
    _Out_ PNET_RXQUEUE_CONFIG NetRxQueueConfig,
    _In_  PFN_RXQUEUE_ADVANCE EvtRxQueueAdvance,
    _In_  PFN_RXQUEUE_SET_NOTIFICATION_ENABLED EvtRxQueueSetNotificationEnabled,
    _In_  PFN_RXQUEUE_CANCEL EvtRxQueueCancel
)
{
    RtlZeroMemory(NetRxQueueConfig, sizeof(NET_RXQUEUE_CONFIG));
    NetRxQueueConfig->Size = sizeof(NET_RXQUEUE_CONFIG);
    NetRxQueueConfig->AlignmentRequirement = NET_RX_QUEUE_DEFAULT_ALIGNMENT;
    NetRxQueueConfig->EvtRxQueueAdvance = EvtRxQueueAdvance;
    NetRxQueueConfig->EvtRxQueueSetNotificationEnabled = EvtRxQueueSetNotificationEnabled;
    NetRxQueueConfig->EvtRxQueueCancel = EvtRxQueueCancel;
}

#define NET_RXQUEUE_GET_PACKET_CONTEXT_TOKEN(_rxqueue, _contexttype)                        \
    NetRxQueueGetPacketContextToken((_rxqueue), WDF_GET_CONTEXT_TYPE_INFO(_contexttype))    \

typedef struct _NET_RXQUEUE_DMA_ALLOCATOR_CONFIG
{
    ULONG Size;

    // DMA enabler to use when allocating buffers
    WDFDMAENABLER DmaEnabler;

    // Maximum logical address to use when allocating buffers,
    // or 0 to indicate there is no maximum address
    PHYSICAL_ADDRESS MaximumPhysicalAddress;

    // Value defining if the memory allocated should have
    // cache enabled or not. WdfDefault will enable cache
    // only if the device is cache coherent
    WDF_TRI_STATE CacheEnabled;

    // Preferred NUMA node to use when allocating memory. If
    // this is MM_ANY_NODE_OK NetAdapterCx will query the 
    // device for the best node to use
    NODE_REQUIREMENT PreferredNode;

} NET_RXQUEUE_DMA_ALLOCATOR_CONFIG, *PNET_RXQUEUE_DMA_ALLOCATOR_CONFIG;

VOID
FORCEINLINE
NET_RXQUEUE_DMA_ALLOCATOR_CONFIG_INIT(
    _Out_ PNET_RXQUEUE_DMA_ALLOCATOR_CONFIG DmaAllocatorConfig,
    _In_ WDFDMAENABLER DmaEnabler)
{
    RtlZeroMemory(DmaAllocatorConfig, sizeof(NET_RXQUEUE_DMA_ALLOCATOR_CONFIG));
    DmaAllocatorConfig->Size = sizeof(NET_RXQUEUE_DMA_ALLOCATOR_CONFIG);

    DmaAllocatorConfig->DmaEnabler = DmaEnabler;
    DmaAllocatorConfig->CacheEnabled = WdfUseDefault;
    DmaAllocatorConfig->PreferredNode = MM_ANY_NODE_OK;
}

//
// NET Function: NetRxQueueCreate
//
typedef
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETRXQUEUECREATE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES RxQueueAttributes,
    _In_
    PNET_RXQUEUE_CONFIG Configuration,
    _Out_
    NETRXQUEUE* RxQueue
    );

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetRxQueueCreate(
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES RxQueueAttributes,
    _In_
    PNET_RXQUEUE_CONFIG Configuration,
    _Out_
    NETRXQUEUE* RxQueue
    )
{
    return ((PFN_NETRXQUEUECREATE) NetFunctions[NetRxQueueCreateTableIndex])(NetDriverGlobals, NetRxQueueInit, RxQueueAttributes, Configuration, RxQueue);
}

//
// NET Function: NetRxQueueNotifyMoreReceivedPacketsAvailable
//
typedef
_IRQL_requires_max_(HIGH_LEVEL)
WDFAPI
VOID
(*PFN_NETRXQUEUENOTIFYMORERECEIVEDPACKETSAVAILABLE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETRXQUEUE RxQueue
    );

_IRQL_requires_max_(HIGH_LEVEL)
VOID
FORCEINLINE
NetRxQueueNotifyMoreReceivedPacketsAvailable(
    _In_
    NETRXQUEUE RxQueue
    )
{
    ((PFN_NETRXQUEUENOTIFYMORERECEIVEDPACKETSAVAILABLE) NetFunctions[NetRxQueueNotifyMoreReceivedPacketsAvailableTableIndex])(NetDriverGlobals, RxQueue);
}

//
// NET Function: NetRxQueueInitGetQueueId
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
ULONG
(*PFN_NETRXQUEUEINITGETQUEUEID)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    PNETRXQUEUE_INIT NetRxQueueInit
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
ULONG
FORCEINLINE
NetRxQueueInitGetQueueId(
    _In_
    PNETRXQUEUE_INIT NetRxQueueInit
    )
{
    return ((PFN_NETRXQUEUEINITGETQUEUEID) NetFunctions[NetRxQueueInitGetQueueIdTableIndex])(NetDriverGlobals, NetRxQueueInit);
}

//
// NET Function: NetRxQueueQueryAllocatorCacheEnabled
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETRXQUEUEQUERYALLOCATORCACHEENABLED)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETRXQUEUE RxQueue,
    _Out_
    PBOOLEAN CacheEnabled
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetRxQueueQueryAllocatorCacheEnabled(
    _In_
    NETRXQUEUE RxQueue,
    _Out_
    PBOOLEAN CacheEnabled
    )
{
    return ((PFN_NETRXQUEUEQUERYALLOCATORCACHEENABLED) NetFunctions[NetRxQueueQueryAllocatorCacheEnabledTableIndex])(NetDriverGlobals, RxQueue, CacheEnabled);
}

//
// NET Function: NetRxQueueGetRingBuffer
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
PNET_RING_BUFFER
(*PFN_NETRXQUEUEGETRINGBUFFER)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETRXQUEUE NetRxQueue
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
PNET_RING_BUFFER
FORCEINLINE
NetRxQueueGetRingBuffer(
    _In_
    NETRXQUEUE NetRxQueue
    )
{
    return ((PFN_NETRXQUEUEGETRINGBUFFER) NetFunctions[NetRxQueueGetRingBufferTableIndex])(NetDriverGlobals, NetRxQueue);
}

//
// NET Function: NetRxQueueGetPacketContextToken
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
PNET_PACKET_CONTEXT_TOKEN
(*PFN_NETRXQUEUEGETPACKETCONTEXTTOKEN)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETRXQUEUE NetRxQueue,
    _In_
    PCNET_CONTEXT_TYPE_INFO ContextTypeInfo
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
PNET_PACKET_CONTEXT_TOKEN
FORCEINLINE
NetRxQueueGetPacketContextToken(
    _In_
    NETRXQUEUE NetRxQueue,
    _In_
    PCNET_CONTEXT_TYPE_INFO ContextTypeInfo
    )
{
    return ((PFN_NETRXQUEUEGETPACKETCONTEXTTOKEN) NetFunctions[NetRxQueueGetPacketContextTokenTableIndex])(NetDriverGlobals, NetRxQueue, ContextTypeInfo);
}

//
// NET Function: NetRxQueueInitAddPacketContextAttributes
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETRXQUEUEINITADDPACKETCONTEXTATTRIBUTES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_
    PNET_PACKET_CONTEXT_ATTRIBUTES PacketContextAttributes
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetRxQueueInitAddPacketContextAttributes(
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_
    PNET_PACKET_CONTEXT_ATTRIBUTES PacketContextAttributes
    )
{
    return ((PFN_NETRXQUEUEINITADDPACKETCONTEXTATTRIBUTES) NetFunctions[NetRxQueueInitAddPacketContextAttributesTableIndex])(NetDriverGlobals, NetRxQueueInit, PacketContextAttributes);
}

//
// NET Function: NetRxQueueInitSetDmaAllocatorConfig
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETRXQUEUEINITSETDMAALLOCATORCONFIG)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_
    PNET_RXQUEUE_DMA_ALLOCATOR_CONFIG DmaAllocatorConfig
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetRxQueueInitSetDmaAllocatorConfig(
    _Inout_
    PNETRXQUEUE_INIT NetRxQueueInit,
    _In_
    PNET_RXQUEUE_DMA_ALLOCATOR_CONFIG DmaAllocatorConfig
    )
{
    ((PFN_NETRXQUEUEINITSETDMAALLOCATORCONFIG) NetFunctions[NetRxQueueInitSetDmaAllocatorConfigTableIndex])(NetDriverGlobals, NetRxQueueInit, DmaAllocatorConfig);
}

//
// NET Function: NetRxQueueGetBufferLayoutHint
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETRXQUEUEGETBUFFERLAYOUTHINT)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETRXQUEUE NetRxQueue,
    _Out_
    PNET_RXQUEUE_BUFFER_LAYOUT_HINT BufferLayoutHint
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetRxQueueGetBufferLayoutHint(
    _In_
    NETRXQUEUE NetRxQueue,
    _Out_
    PNET_RXQUEUE_BUFFER_LAYOUT_HINT BufferLayoutHint
    )
{
    ((PFN_NETRXQUEUEGETBUFFERLAYOUTHINT) NetFunctions[NetRxQueueGetBufferLayoutHintTableIndex])(NetDriverGlobals, NetRxQueue, BufferLayoutHint);
}



WDF_EXTERN_C_END

#endif // _NETRXQUEUE_H_

